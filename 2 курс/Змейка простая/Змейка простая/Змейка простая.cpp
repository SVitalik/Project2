#include <iostream>
#include <conio.h>
#include <Windows.h>
#include <math.h>
using namespace std;


bool gameOver;//переменная
const int width = 20;//ширина полей
const int height = 20;//высота полей
int x, y, fruitX, fruitY, score;//переменные
int tailX[100], tailY[100];//переменные масивов для координатов хвоста
int nTail;//переменная, в которую помещаеться количество елементов в нашем хвосте
enum eDirection {STOP = 0, LEFT, RIGHT, UP, DOWN  };//указываем управление персонажем
eDirection dir;//dir является переменой 


void Setup() //это функция настройка нужных параметров при запуске игры
{
    gameOver = false;//по умолчанию делать чтобы мы изначально не проиграли
    dir = STOP;//чтобы в начале игры змейка стояла на месте
    x = width / 2 - 1;//начальные положение змейки по центру
    y = height / 2 - 1;//начальные положение змейки по центру
    fruitX = rand() % width;//появление фруктов рандомно по ширине
    fruitY = rand() % height;//появление фруктов рандомно по высоте
    score = 0;//в начале общий счет будет равен 0
}



void Draw()//это функция рисует всю игру (в данной игре рисует карту)
{
    Sleep(50);
    /*srand(time(0));*/
    system("cls");//будет постоянно очищать терминал когда вызывает карту
    for (int i = 0; i < width + 1; i++)//верхняя граница
        cout << "-";
    cout << endl;

    for (int i = 0; i < height; i++)//высота
    {
        for (int j = 0; j < width; j++)//ширина
        {
            if (j == 0 || j == width - 1)//проверяет чтобы сбоку была граница
                cout << "|";//выводим границу решеткой сбоку (первая и последеяя будет с решеткой)
            if (i == y && j == x)//координаты змейки
                cout << "0";//как будет выглядеть змейка
            else if (i == fruitY  && j == fruitX)//координаты фрукта
                cout << "$";//как будет выглядеть фрукт
            else
            {
                bool print = false;//делаем чтобы хвост появлялся за змейкой а не гдето на карте (если мы рисуем новый символ для нашего хвоста то нам не надо рисовать пробел)
                for (int k = 0; k < nTail; k++)//рисуем хвост 
                {
                    if (tailX[k] == j && tailY[k] == i)//если координата по х будет ровна j (коодинаты по х змеи) а также если координаты по y будет ровна i 
                    {
                        print = true;
                        cout << "o";//будет выводить такой знак
                    }
                        
                }
                if(!print)//если print равен false то тогда ставим пробел 
                    cout << " ";//все остальные поля заполняються пустотой (все остальные будет пустота)

            }
                
        }
        cout << endl;//перекидываемся на новый ряд
    }

    for (int i = 0; i < width + 1; i++)//нижняя граница
        cout << "-";
    cout << endl;
    cout << "Score: " << score << endl;//выводим общий счет на екран
    /*cout << "rerstart: " << x << gameOver;*/
    
}


void Imput()// это функция отслежует все нажатие которые поступают от пользователя
{
    if (_kbhit())//функция которая возвращает истину если пользователь нажал на какуе-ту либо кнопку на клавиатуре (она отследжует на какую именно кнопку он нажал)
    {
        switch (_getch ())//благодаря гетч мы можем отследить что нажал пользователь
        {
        case 'a'://если пользователь нажал букву а то он двигаеться в лево
            if (dir != RIGHT)
            dir = LEFT;
            break;
        case 'd'://если пользователь нажал букву d то он двигаеться в вправо
            if (dir != LEFT)
            dir = RIGHT;
            break;
        case 'w'://если пользователь нажал букву w то он двигаеться в вверх
            if (dir != DOWN)
            dir = UP;
            break;
        case 's'://если пользователь нажал букву s то он двигаеться в вниз
            if (dir != UP)
            dir = DOWN;
            break;
        case 'x'://если пользователь нажал букву x то он заканчивает игру
            system("pause");
            /*gameOver = true;*/
            break;
        }
    }
}


void Logic()//логика игры
{
    int prevX = tailX[0];//предыдущая позиция по х (для отображенеи хвоста)
    int prevY = tailY[0];//предыдущая позиция по y (для отображенеи хвоста)
    int prev2X, prev2Y;//мы добавляем следущий елемент (сюда мы добавляем второй елемент в хвосте
    tailX[0] = x;//значение координаты змейки для нашего первого елемента в хвосте по х
    tailY[0] = y;//значение координаты змейки для нашего первого елемента в хвосте по у
    for (int i = 1; i < nTail; i++)//почему еденица потому что выше мы записали первое значение (0), дальше i будет идти до количество елементов в нашем хвосте, и i++ будет на 1 увеличиваться 
    {
        prev2X = tailX[i];//добавляем следущий елемент хвоста по х
        prev2Y = tailY[i];//добавляем следущий елемент хвоста по у
        tailX[i] = prevX;//сохраняем координату prevX
        tailY[i] = prevY;//сохраняем координату prevY
        prevX = prev2X;//устанавливаем новое значение prevX которое мы поместили в prev2X
        prevY = prev2Y;//устанавливаем новое значение prevY которое мы поместили в prev2Y
    }
    switch (dir)//движение змейки
    {
    case LEFT://если нажать влево то х будет идти влево то есть уменшаться 
        x--;
        break;
    case RIGHT://если нажать вправо то х будет идти вправо то есть увеличиваться 
        x++;
        break;
    case UP://если нажать вверх то у будет идти вверх то есть уменшаться
        y--;
        break;
    case DOWN://если нажать вниз то у будет идти вниз то есть увеличиваться 
        y++;
        break;
    }
    //if (x > width || x < 0 || y > height || y < 0 )//если змейка больше границ то есть выходит за границы игра заканчиваеться 
    //    gameOver = true;//игра заканчивается 

    if (x >= width - 1)//если змейка врезаеться в стенку она выходит с другой стороны, если х больше и ровна стороне 
        x = 0;// тогда х ровно 0
    else if (x < 0)
        x = width - 2;// тогда мы берем обратные числа и она появляется с обратной стороны (если мы вышли и у нас больше чем сторона 21... то кордината по х становится 0 и мы с обратной стороны 

    if (y >= height)//если змейка врезаеться в стенку она выходит с другой стороны, если х больше и ровна стороне 
        y = 0;// тогда х ровно 0
    else if (y < 0)
        y = height - 1;// тогда мы берем обратные числа и она появляется с обратной стороны (если мы вышли и у нас больше чем сторона 21... то кордината по х становится 0 и мы с обратной стороны

    for (int i = 0; i < nTail; i++)//стартуем от 0 до количество елементов в своем хвосте
    {
        if (tailX[i] == x && tailY[i] == y)//проверяем если координаты хвоста основной змейке будет сходиться по х будет ровна х и дополнительно будут сходиться по у     
            gameOver = true;//если мы попадаем на свой хвост игра заканчивается      
    }


    if (x == fruitX && y == fruitY)//появление фруктов и возможность их есть
    {
        score += 10;//добавляет к результату
        fruitX = rand() % width;//каждый раз появление фруктов рандомно по ширине
        fruitY = rand() % height;//каждый раз появление фруктов рандомно по высоте
        nTail++;// хвост становиться на единичку больше
    }
}


int main()
{
    Setup();
    while (!gameOver)//постоянно вызывает карту делая блики на карте
    {
        Draw();
        Imput();
        Logic();
    }
}


